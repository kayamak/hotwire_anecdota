---
title: モーダル
layout: article
order: 005
published: true
---

ウェブUIでよく見かけるモーダルですが、Hotwireで実装したというブログ記事はよく見かけます。そして多くの場合は「JavaScriptをほとんど使わないでできた！」っていうことを誇っています。

**しかしモーダルってそんな簡単なものでしょうか？私はそう思いません。** Hotwireを使えば、画面にモーダルを表示するのは簡単です。しかしUIは使ってこそ価値があります。細かい動作からアクセシビリティまでをJavaScriptなしで実装するのは無理です。

ここでは[モーダルUIの難しさ](https://zenn.dev/yend724/articles/20220511-pc51v32llyzu8kws)をしっかり見つめて、ちゃんとしたモーダルをHotwireで作る方法を考えたいと思います。また**Hotwireでできる最高のものを紹介したのちに、トーンダウンした簡単なものの作り方を紹介します**。

なお、**ここでお見せするものは、私が普段作成するモーダルよりも随分と柔軟性が高いものです**。通常はもっと簡単に実装します。いざとなったときでも対応できる**最終兵器**ぐらいに考えていただければと思います。

また多少脱線しますが、そもそもモーダルが本当に必要かどうかもこの機会に再考していただければと思います。これについては、個人的な意見ですが、[別途議論しました](/opinions/should_you_use_modals)。

## モーダルで考えるべきポイント --- modal-considerations

モーダルで実装する上で、以下のことを検討しておくべきかと思います。簡易的なモーダルの作り方だと、この一部は対応できますが、すべてには対応できません。

* モーダル表示のアニメーションは必要か否か:
  * モーダルの表示・非表示の際にアニメーションをつけることはよくあります。このためには、モーダルのHTMLを唐突に出現させたり消したりするだけでは不十分で、配慮をします
* サーバから非同期でデータ（HTML）を取得する必要があるか？: 
  * サーバ通信をすると、レスポンス遅延が発生します。レスポンスが得られる前に、ユーザに的確にフィードバックします（pending UI）
* モーダルの中でCRUDをするか？:
  * CRUDがあり、かつサーバサイドバリデーションのフィードバックをする場合は動作が複雑になります
  * サーババリデーションをフィードバックする際、成功失敗によって動作を変えます
     * 例えば成功した場合の動作として、自動的にモーダルを閉じて、背景画面も更新します
     * 一方で失敗した場合はモーダルを開いたままにし、エラーを表示します
  * 成功した時に自動的にモーダルを閉じる例を挙げましたが、一方で開いたままにするケースもあります
  * CreateやUpdateが成功したのちに、別のページにリダイレクトするかもしれしれません。あるいは背景のページを更新するだけかもしれません
* キーボードショートカットを含め、 [モーダルダイアログに期待されるアクセシビリティ](https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/)がいくつかあります。モーダルを自作する場合はこれらをある程度用意する必要があります

## 今回の設計のポイント --- points-to-consider

モーダルは複数のアクションがあり、条件によって処理が分岐しますので、しっかり作ろうと思う場合は比較的複雑なUIになります。Hotwireを使えばコードの量は少なく済みますが、考えること自体を省略できるわけではありませんので、一つ一つ解説します。

### モーダルの開閉とデータの読み込み --- open-close-and-requesting-data

ここの部分は[ちゃんとしたモーダルを表示する](/examples/modal/modal-show-with-animation)で解説します。


1. モーダルの内容はサーバから非同期で取得します。このためにTurboを使います。
   1. サーバからのデータ取得は複数回行われます
      1. 最初にモーダルを表示するとき
      2. フォームを送信し、結果(成功・失敗)を受け取る時
   2. 初回のデータ取得は細かい制御がありませんので、Turbo Framesで十分です
   3. フォームを送信した場合は成功・失敗(バリデーションエラー)の複数のレスポンスが想定され、それぞれで対応が変わります
      1. 成功した場合はトーストを表示し、元のページを再読み込みします。さらにモーダルを自動的に閉じます
      2. 失敗した場合は、同じページにエラー表示を重ねて表示します
      3. このように柔軟に結果を出し分けるために、サーバ側から制御できるTurbo Streamsを使います
2. サーバレスポンスが遅い可能性を考慮し、レスポンスを待たずに、ボタンをクリックした瞬間に先にモーダルを開きます。そのためにTurboリクエストと同時に、並行してStimulusでモーダルを開きます
   1. モーダル非表示のアニメーションもStimulusで制御します
   2. CSSが複雑になるため、モーダルにStimulusのValuesステートを持たせます
3. モーダルを閉じるアクションとしては以下のものを用意します
   1. 「閉じる」ボタンのクリック
   2. ESCキー
   3. 背景の黒幕をクリック
4. 黒幕で隠された背景の画面は、キーボードイベントやスクロールイベントを受け付けないようにします 

### フォームのデータを送信し、レスポンスを受信 --- send-and-respond-to-response

ここの部分は[フォーム送信成功でモーダルを隠す](/examples/modal/modal-form-success-and-hide)で解説します。

1. `form`の送信はTurboを使います
2. フォーム送信が成功したい場合
   1. トーストを表示し、背景画面のデータも更新します
   2. 複数の要素を更新しますので、Turbo Streamsが適切です（Morphingでも可能ですが、それはまた別に話します）
   3. 自動的にモーダルを（アニメーション付きで）閉じます。これはStimulusで処理します
2. フォーム送信が失敗した場合（バリデーションエラー）
   1. モーダルを開いたままにします
   2. エラーを表示します

### ポイントまとめ --- summary-of-points

![interactive-flow-hotwire.webp](content_images/interactive-flow-hotwire.webp "max-w-[600px] mx-auto")

上述したことをすべて行いますので、下半分の<span class="text-blue-600">青色のTurboのところ</span>、および一番下の<span class="text-green-600">緑色のStimulusで補完するTurbo前後の２箇所</span>をすべて行う感じになります。

**なお上記の設計は、Hotwireで柔軟性をMaxにした時のものです**。

[より単純化したケースの考え方については別途解説](/examples/modal/simpler-modals)します。

